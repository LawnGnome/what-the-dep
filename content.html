<!DOCTYPE HTML>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>What the dep?</title>

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<section id="title">
					<h1>What the dep</h1>
					<h2>is going on with Go dependency management?</h2>
					<h3>Adam Harvey</h3>
					<aside class="notes">
					</aside>
				</section>

				<section>
					<section id="prehistory">
						<div class="todo">content</div>
						<aside class="notes">
							Five years from now, you probably won't need to know any history.
							Unfortunately, right now, to understand where we're at, you need
							a little bit of background in how Go got there.
						</aside>
					</section>

					<section id="gopath">
						<div class="todo">content</div>
						<aside class="notes">
							The zeroth generation of dependency management in Go was
							essentially not having dependency management: you had
							<code>go get</code> to download the current master of whatever
							package you were depending on, and you had to keep everything in
							a `$GOPATH`, which would generally be a single workspace for all
							your projects.
						</aside>
					</section>

					<section id="gopkg">
						<div class="todo">content</div>
						<aside class="notes">
							While there were some interesting hacks for things like gopkg.in
							to try to pin to a version, they weren't generally useful, since
							libraries had to set up their import paths to only use gopkg.
						</aside>
					</section>
				</section>

				<section>
					<section id="clone-wars">
						<div class="todo">content</div>
						<aside class="notes">
							This situation wasn't really tenable for anyone who actually had
							dependencies, so a set of competing first generation tools sprung
							up to implement package and vendor management to varying degrees.
						</aside>
					</section>

					<section id="glide">
						<div class="todo">content</div>
						<aside class="notes">
							Those with ambitions of being the standard package manager
							generally mimicked other languages: Glide, for example,
							explicitly called out Cargo, NPM, Composer, and a few others as
							direct inspirations.
						</aside>
					</section>

					<section id="vendor">
						<div class="todo">content</div>
						<aside class="notes">
							The Go team did take some note: Go 1.5 shipped with a vendor
							experiment in 2015, which allowed you (or your tool) to set up
							vendor directories with special import resolution rules, which
							made things a little better.
						</aside>
					</section>

					<section id="too-many-cooks">
						<div class="todo">content</div>
						<aside class="notes">
							Nevertheless, there were a couple of issues. One was `$GOPATH`
							itself: even with vendor support, managing dependencies for
							multiple projects within a single workspace wasn't always easy.
							And there were honestly too many alternatives, each with their
							own metadata format, tagging expectations, and with none of them
							really getting the care and attention needed to get them to
							acceptable quality levels.
						</aside>
					</section>
				</section>

				<section>
					<section id="survey-monkey">
						<div class="todo">content</div>
						<aside class="notes">
							For years, the biggest problem noted in the Go developer survey
							was dependency management. That set of first generation tools
							helped a little, but didn't really move the needle.
						</aside>
					</section>

					<section id="dep">
						<div class="todo">content</div>
						<aside class="notes">
							Sam Boyer went off and did lots of research and came up with a
							design for a tool that he called <code>dep</code>. It was
							developed with the explicit intention of being the official tool
							for Go, shipped with the language tooling.
						</aside>
					</section>

					<section id="dep-integration">
						<div class="todo">content</div>
						<aside class="notes">
							As a result, it integrated with existing features: it relied on
							<code>$GOPATH</code> so as not to disrupt existing workflows. At
							the same time, though, it looked recognisable to users familiar
							with other languages' package managers: there were separate
							install/update steps, and dependency resolution used the same
							general SAT solver approach everyone else uses.
						</aside>
					</section>

					<section id="ruh-roh">
						<div class="todo">content</div>
						<aside class="notes">
							You will note that I'm using the past tense here. Because before
							<code>dep</code> became the standard tool, something else
							happened.
						</aside>
					</section>
				</section>

				<section>
					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							This brings us to 2018. By this point, the 2017 Go survey had
							happened, and for the first time, dependency management wasn't
							the top pain point. (It was generics, which in fairness had
							always been a close second.)
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							Russ Cox, on the Go team, had been dissatisfied with the
							direction of <code>dep</code>, and instead proposed a tool called
							<code>vgo</code> in a series of essays.
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							<code>vgo</code> was a more radical proposal. Firstly, it got rid
							of the NP-complete resolution issue by sidestepping the idea of
							trying to solve package dependency graphs altogether, and instead
							working backwards from minimum requirements with something Russ
							called "Minimal Version Selection".
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							Secondly, <code>vgo</code> mostly got rid of the idea of
							<code>$GOPATH</code> for most developers. It still exists, but in
							practice, you now have a workspace per project ("module") with a
							<code>go.mod</code> file at its root, which would act as the
							effective <code>$GOPATH</code> root.
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							With some refinement, <code>vgo</code> was quickly (and rather
							controversially) adopted by the Go team, and shipped as a
							nominally experimental feature in Go 1.11 in August, this time as
							the <code>go mod</code> family of commands. In Go 1.12, it will
							no longer be experimental, and will become the officially blessed
							solution. Now is a good time to get on board.
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							So, now is a good time to get on board. Let's talk a little about
							the practicalities of using <code>go mod</code>, and then we'll
							get into a few demos.
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							As mentioned a minute ago, the key is that you have a
							<code>go.mod</code> file at the root of your project. This is
							roughly equivalent to, say, a <code>package.json</code>: it
							contains the canonical import path for your project, and its
							dependency rules.
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							Generally speaking, you create it using <code>go mod init</code>,
							but they are human readable and writable. It uses its own special
							syntax because of course it does, but it's not terribly hard to
							understand, and it kind of looks like an <code>import</code>
							block if you turn your head and squint a bit.
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							Another way in which <code>go mod</code> differs is that it
							doesn't use lock files: because of the way MVS works, it should
							always generate the same set of versions for the same inputs,
							even if newer versions have been released. There is a
							<code>go.sum</code> file which is recommended to be committed,
							but it only contains checksums to prevent shenanigans.
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							The final thing to know is that you are <em>absolutely</em>
							opting in to semantic versioning. In practice, the Go ecosystem
							is new enough that this isn't generally a huge concern: most
							things do use semver, but <code>go mod</code> makes numerous
							assumptions that semver is in fact in use. So if you're writing a
							library, factor that in.
						</aside>
					</section>

					<section id="">
						<div class="todo">content</div>
						<aside class="notes">
							If the demo gods are kind today, let's look at a few examples.
						</aside>
					</section>
				</section>

				<section>
					<section id="new-project">
						<pre><code class="sh" data-trim>
$ go mod init github.com/LawnGnome/example
go: creating new go.mod: module github.com/LawnGnome/example
$ cat go.mod
module github.com/LawnGnome/example
						</code></pre>
						<aside class="notes">
							Starting a new project is easy: you run <code>go mod init</code>.
							If you don't already have a <code>.git</code> directory, you can
							provide the import path as a parameter.
						</aside>
					</section>

					<section id="existing-project">
						<pre><code class="sh" data-trim>
$ go mod init
go: creating new go.mod: module github.com/aecerbot/gpsd
go: copying requirements from glide.lock
$ go build
go: finding github.com/golang/protobuf v0.0.0-20160930204858-df1d3ca07d2d
go: finding github.com/aecerbot/protocols v0.0.0-20161004060151-282bc827067e
go: finding github.com/adrianmo/go-nmea v0.0.0-20150824134349-c5f07dff7cbb
go: finding golang.org/x/sys v0.0.0-20161023150541-c200b10b5d5e
go: finding gopkg.in/bugst/go-serial.v1 v1.0.0-20161022203751-04302f262ca3
go: finding gopkg.in/bsm/ratelimit.v1 v1.0.0-20160220154919-db14e161995a
go: finding gopkg.in/redis.v4 v4.2.3
go: downloading github.com/adrianmo/go-nmea v0.0.0-20150824134349-c5f07dff7cbb
go: downloading github.com/aecerbot/protocols v0.0.0-20161004060151-282bc827067e
go: downloading gopkg.in/redis.v4 v4.2.3
go: downloading github.com/golang/protobuf v0.0.0-20160930204858-df1d3ca07d2d
go: downloading gopkg.in/bugst/go-serial.v1 v1.0.0-20161022203751-04302f262ca3
go: downloading gopkg.in/bsm/ratelimit.v1 v1.0.0-20160220154919-db14e161995a
						</code></pre>
						<aside class="notes">
							Let's say you have an existing project. <code>go mod init</code>
							will try fairly hard to intuit your existing dependencies. If you
							have metadata for dep, or Glide, or a bunch of other first
							generation tools, these will be parsed and a new
							<code>go.mod</code> will be generated.
						</aside>
					</section>

					<section id="new-clone">
						<pre><code class="sh" data-trim>
$ go build
go: finding github.com/golang/protobuf v0.0.0-20160930204858-df1d3ca07d2d
go: finding github.com/aecerbot/protocols v0.0.0-20161004060151-282bc827067e
go: finding github.com/adrianmo/go-nmea v0.0.0-20150824134349-c5f07dff7cbb
go: finding golang.org/x/sys v0.0.0-20161023150541-c200b10b5d5e
go: finding gopkg.in/bugst/go-serial.v1 v1.0.0-20161022203751-04302f262ca3
go: finding gopkg.in/bsm/ratelimit.v1 v1.0.0-20160220154919-db14e161995a
go: finding gopkg.in/redis.v4 v4.2.3
go: downloading github.com/adrianmo/go-nmea v0.0.0-20150824134349-c5f07dff7cbb
go: downloading github.com/aecerbot/protocols v0.0.0-20161004060151-282bc827067e
go: downloading gopkg.in/redis.v4 v4.2.3
go: downloading github.com/golang/protobuf v0.0.0-20160930204858-df1d3ca07d2d
go: downloading gopkg.in/bugst/go-serial.v1 v1.0.0-20161022203751-04302f262ca3
go: downloading gopkg.in/bsm/ratelimit.v1 v1.0.0-20160220154919-db14e161995a
						</code></pre>
						<aside class="notes">
							For a newly cloned project with a <code>go.mod</code> and
							<code>go.sum</code>, this is even easier: <code>go build</code>
							will build you a binary straight up, retrieving whatever is
							required on the fly.
						</aside>
					</section>
				</section>

				<section id="thanks">
					<h2>Questions?</h2>
					<aside class="notes">
					</aside>
				</section>
			</div>
		</div>

	</body>
</html>
<!-- vim: set nocin ai noet ts=2 sw=2: -->
